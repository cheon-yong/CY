# 2024-12-26

## 1. 개발 진행 및 완료 사항

1. Gameplay Ability의 네트워크화
2. AttributeSet과 연동되는 HpBar 추가

## 2. 오늘 발생한 이슈 및 고민

1. 여전히 클라이언트의 Ability 가 발생하면 2번 발생하거나 아예 발동되지 않음.
2. AttributeSet의 Health값은 변하지만 UI가 변하지 않는 현상
3. 클라이언트에서만 서버의 HP 값이 변하지 않는 현상

## 3. 고민 해결 방법 또는 새로 배운 내용

1. 디버그를 하던 중 클라이언트에 부여된 Ability가 서버에 부여되었다는 것을 알게 되었다. 해당 과정은 GiveAbility 코드를 서버 RPC로 처리하는 코드에서 발생하였는데 GiveAbility 자체도 서버에서만 처리되기 때문에 굳이 RPC를 사용하지 않고 `HasAuthority()`로 서버에서만 실행되게 변경하였다.
2. 이러한 문제는 클라이언트의 서버의 AbilitySystemComponent 초기화 타이밍에 차이 때문에 발생하였다. 

해당 문제는 클라이언트의 초기화 타이밍에 대해 이해도를 높여주는 계기가 되었다. WidgetComponent는 BeginPlay 타이밍 이후에 InitWidget을 호출한다. 서버에서는 `PossessedBy` 단계에서 `Character`의 ASC를 초기화했기 때문에 서버의 Widget은 정상적으로 `AttributeSet`과 연동이 가능하다.

그러나 클라이언트에서는 서버로부터 `PlayerState`를 replicate 받기 때문에 `PossessedBy` 함수가 호출되지 않고 `OnRep_PlayerState` 함수가 호출된다. 이러한 문제 때문에 클라이언트의 Widget은 nullptr을 전달받게 되고 정상적으로 초기화되지 않는 문제가 생긴 것이다.

이러한 문제를 해결하기 위해 Delegate를 이용하였다. 클라이언트에서 사용할 수 있는 기법으로 초기화단계에서 ASC를 참조할 때 ASC가 nullptr 이라면 `CYCharacter`에 생성해둔 `OnInitASC` 이라는 Delegate에 함수를 연결해두어 ASC가 초기화되면 다음 초기화 단계를 진행하도록 하였다.
3. 클라이언트에서 서버로부터 HP 값을 수신하지 못하는 현상은 `DOREPLIFETIME_CONDITION_NOTIFY(UCYAttributeSet, Health, COND_None, REPNOTIFY_Always);` 코드 중 `COND_None` 때문이었다. 지금은 수정해서 None이지만 이전에는 OwnerOnly였는데 해당 조건은 Actor를 소유한 Owner에게만 Replicate 되기 때문에 클라이언트는 Health 정보를 수신할 수 없는 것이었다.

## 4. 참고할 만한 레퍼런스

## 5. 특이사항

이제 발생했던 문제들을 모두 해결하고 기초적인 근접 공격 시스템을 완성하였다.

## 6. 전체 회고

여전히 네트워크에 대한 이해도가 모자라다고 생각하였다. 특히 초기화 타이밍이 서버와 클라이언트가 다르다는 내용은 언리얼 네트워크 강의 내용에 있었던 것 같은데 다시 한번 복습하면서 기초를 다져야겠다.

## 7. 내일 할 일

투사체를 던지는 어빌리티 생성. 가능하다면 죽는 모션까지