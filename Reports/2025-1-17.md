# 2025-1-17

## 1. 개발 진행 및 완료 사항

1. 아이템 장착 및 해제
2. 아이템 드랍
3. 인벤토리 관련 UI 완성

## 2. 오늘 발생한 이슈 및 고민

Lyra의 Equipment 방식을 사용해서 적용하려고 했으나 ItemActor를 생성하는 부분이 적용하기 어려웠다.

 Lyra Item 시스템 중 Fragment라는 시스템이 있다. `ItemDefinition`에 추가되어 아이템에 다양한 기능을 추가한다.

Fragment는 말 그대로 기능을 파편화한 개념으로 Lyra에서는 Item에 Equippable, Set Stats과 같은 기능을 추가하여 아이템의 특성을 구현하고 있다.

해당 시스템을 구현하는 중 EquippableItem을 구현하는 과정에서 새로운 개념들인 `EquipmentDefinition`과 `EquipmentInstance`를 어떻게 대체해야할 지 고민이 생겼다.

처음에는 이러한 클래스를 추가하려고 하였으나 장착 시 아이템을 Spawn 하는 과정에서 `Init` 함수를 호출해야하는데 전달인자인 `ItemDefinition`을 추가해야하는데 그렇게 되면 `EquipmentInstance`와 `ItemDefinition` 사이에 의존성이 생기게 되어 해당 문제를 해결해야했다.

## 3. 고민 해결 방법 또는 새로 배운 내용

고민 해결 방법

1. 아직 고민을 해결한 부분은 아니다. 앞으로 해당 내용에 대해서는 구현 방식을 고민해봐야하는데 의존성을 줄이기 위해서는 구조를 새로 작성해야하기 때문에 Equipment에 관련된 클래스를 생성하지 않고 Fragment에 직접적으로 Definition을 추가하는 방식으로 구현해야겠다.

새로 배운 내용

1. `FFastArraySerializer`의 함수 중 `MarkItemDirty(item)` 함수와 `MarkArrayDirty`는 네트워크 동기화를 트리거하는 함수이다.

`MarkItemDirty(item)` 함수는 배열 내 특정 항목에 대해서만 변경사항을 표시하는 함수이다. 해당 함수를 이용하면 배열 전체가 Replication 되는 것을 방지할 수 있다.

`MarkArrayDirty`는 ItemDirty와는 다르게 배열 전체를 변경사항으로 표시한다. 배열에 요소가 추가되거나 삭제되었을 때 또는 크기나 순거 같이 배열의 구조 자체가 변경되었을 때 사용한다.
2. `ReplicateSubobjects()` 함수는 특정 객체가 네트워크 복제를 지원하는 subobject를 보유하고 있을 때 해당 Subobject를 복제할 때 사용한다. 

매개변수는 다음과 같다.
    - **`UActorChannel* Channel`**:
        - 서브오브젝트가 복제될 채널을 나타낸다.
        - 이 채널을 통해 서버와 클라이언트 간 데이터 전송이 이루어진다.
    - **`FOutBunch* Bunch`**:
        - 네트워크 데이터 전송 시 사용할 데이터 패킷(데이터 덩어리).
        - 복제할 데이터를 여기에 기록한다.
    - **`FReplicationFlags* RepFlags`**:
        - 복제 동작을 제어하는 플래그다.
        - 예를 들어, 해당 복제가 서버에서 클라이언트로만 이루어져야 하는지 등을 나타낸다.
    
    반환 값은 bool로 복제가 성공적으로 이루어졌는지에 대한 여부를 나타낸다. 하나 이상의 Subobejct가 복제되면 true, 그렇지 않으면 false를 반환한다.
    
    Lyra에서는 EquipmentComponent의 EquipmentList를 Replication할 때 사용한다.
    
3. Unreal 의 Iris
언리얼의 차세대 네트워크 시스템으로 기존 Actor 기반의 복제 시스템을 보완하기 위해 설계되었다. 네트워크 성능 최적화, 확장성, 복잡한 게임 데이터 동기화 요구 조건을 충족시키기 위해 도입되었다.
    - **데이터 중심 복제(Data-Oriented Replication)**:
        - 기존의 Actor 중심 복제 방식에서 벗어나, 데이터 자체를 복제의 기본 단위로 사용
        - 더 세부적인 데이터 추적 및 동기화가 가능하며, 불필요한 데이터 전송을 줄일 수 있음
    - **네트워크 대역폭 최적화**:
        - **Selectively Replicated State**: 플레이어가 실제로 필요로 하는 데이터만 전송.
        - 네트워크 트래픽 분석 및 제어를 통해 더 나은 성능 제공.
    - **확장성(Scalability)**:
        - 대규모 멀티플레이어 게임에서 효과적으로 동작하도록 설계.
        - 다량의 객체와 데이터를 효율적으로 관리 및 복제 가능.
    - **상태 추적(State Tracking)**:
        - 데이터의 변경 사항을 더 효율적으로 추적.
        - 상태 변경이 감지되면 필요한 데이터만 전송.
    - **Custom Replication Logic**:
        - 데이터 전송의 우선순위 및 조건을 개발자가 세부적으로 제어 가능.
        - 예를 들어, 특정 조건에서만 데이터 복제 또는 특정 클라이언트에게만 데이터 전송.
    
    ### **Iris의 구성 요소**
    
    1. **NetObject**:
        - Iris에서 복제의 기본 단위.
        - 기존의 Actor와 비슷한 역할을 하지만, 데이터 중심으로 설계됨.
    2. **Replication State**:
        - 복제될 데이터를 정의하는 구조체.
        - NetObject와 연결되어 있으며, 데이터의 변경 사항을 추적.
    3. **NetBlob**:
        - 대규모 데이터 전송을 위한 블록 단위의 데이터.
        - 예를 들어, 맵 로드 시 큰 데이터를 전송하거나, 플레이어 프로필 데이터를 초기화할 때 사용.
    4. **Condition**:
        - 데이터 전송 여부를 결정하는 조건.
        - 예: 특정 거리 안에 있는 플레이어에게만 데이터 전송.
    
    ### **Iris의 장점**
    
    1. **효율적인 대역폭 사용**:
        - 클라이언트가 필요로 하지 않는 데이터를 전송하지 않음으로써 네트워크 자원을 절약.
    2. **세밀한 데이터 제어**:
        - 특정 데이터를 조건부로 복제하거나 복제 우선순위를 설정할 수 있음.
    3. **확장성**:
        - 수백 또는 수천 개의 객체와 플레이어를 지원하는 대규모 멀티플레이어 게임에 적합.
    4. **모듈화된 설계**:
        - 특정 데이터 복제 요구 사항에 맞게 쉽게 확장 및 사용자 정의 가능.
    5. **낮은 지연 시간**:
        - 필요한 데이터만 전송하므로 복제에 소요되는 지연 시간이 줄어듦.
    

## 4. 참고할 만한 레퍼런스

## 5. 특이사항

차세대 네트워크 시스템은 Iris에 대해서 한번 더 알아봐야겠다.

## 6. 전체 회고

오랜만에 개발을 진행한 것 같다. 요즘 진로에 대한 고민이 들면서 개발을 망설였는데 완성도 못하고 후회하는 것보다 완성하고 후회하는 것이 여러모로 도움이 될 것 같아서 완성하기로 결정하였다.

기획자의 길도 고민을 해보았으나 우선 프로그래머로서 지식과 경험을 살려 게임 개발자로 성장하고 기획적인 부분을 추가적으로 증진해야겠다.

오늘부터 다시 꾸준히, 열심히 개발하여 꼭 게임 프로그래머가 되어야겠다.

## 7. 내일 할 일

아이템 장착, 해제, 드랍, 관련 UI 완성